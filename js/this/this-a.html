<!--

In javascript `this` can be different, 
here we test a few cases and inspect into it.

What does `this` refer to in the function doSomething()?


  function doSomething() {
     this.style.color = '#cc0000';
  }


Concept of `this` is commonly used in object oriented programming, such as in
C++, Ruby, Python, and more. 

Javascript makes it harder by letting `this` refers to different objects
according to conditions.

When running in browsers, the global object would be `window`, for functions
defined in global context, `this` can refer to `window`.

But when it's event handler, this can refer to the HTML element where the event
is targeted. 

Knowing the above clear can be good help when play with Javascript.


------------ window --------------------------------------
|                                          / \           |
|                                           |            |
|                                          this          |
|   ----------------                        |            |
|   | HTML element | <-- this         -----------------  |
|   ----------------      |           | doSomething() |  |
|               |         |           -----------------  |
|          --------------------                          |
|          | onclick property |                          |
|          --------------------                          |
|                                                        |
----------------------------------------------------------

If we execute doSomething() without any more preparation the this keyword
refers to the window and the function tries to change the style.color of the
window. Since the window doesn't have a style object the function fails
miserably and produces JavaScript errors.

Copying

So if we want to use this to its full extent we have to take care that the
function that uses it is "owned" by the correct HTML element. In other words,
we have to copy the function to our onclick property. Traditional event
registration takes care of it.


  element.onclick = doSomething;


The function is copied in its entirety to the onclick property (which now
becomes a method). So if the event handler is executed this refers to the HTML
element and its color is changed.


------------ window --------------------------------------
|                                                        |
|                                                        |
|                                                        |
|   ----------------                                     |
|   | HTML element | <-- this         -----------------  |
|   ----------------      |           | doSomething() |  |
|               |         |           -----------------  |
|          -----------------------          |            |
|          |copy of doSomething()|  <-- copy function    |
|          -----------------------                       |
|                                                        |
----------------------------------------------------------

The trick is of course that we can copy the function to several event handlers.
Each time this will refer to the correct HTML element:

------------ window --------------------------------------
|                                                        |
|                                                        |
|                                                        |
|   ----------------                                     |
|   | HTML element | <-- this         -----------------  |
|   ----------------      |           | doSomething() |  |
|               |         |           -----------------  |
|          -----------------------          |            |
|          |copy of doSomething()|  <-- copy function    |
|          -----------------------          |            |
|                                           |            |
|   -----------------------                 |            |
|   | another HTML element| <-- this        |            |
|   -----------------------     |           |            |
|               |               |           |            |
|          -----------------------          |            |
|          |copy of doSomething()|  <-- copy function    |
|          -----------------------                       |
|                                                        |
----------------------------------------------------------

Thus you use this to the fullest extent. Each time the function is called, this
refers to the HTML element that is currently handling the event, the HTML
element that "owns" the copy of doSomething().


Referring
---------


However, if you use inline event registration

<element onclick="doSomething()">

you do not copy the function! Instead, you refer to it, and the difference is
crucial. The onclick property does not contain the actual function, but merely
a function call:

doSomething();

So it says “Go to doSomething() and execute it.” When we arrive at
doSomething() the this keyword once again refers to the global window object
and the function returns error messages.

------------ window --------------------------------------
|                                          / \           |
|                                           |            |
|                                          this          |
|   ----------------                        |            |
|   | HTML element | <-- this         -----------------  |
|   ----------------      |           | doSomething() |  |
|               |         |           -----------------  |
|          -----------------------         / \           |
|          | go to doSomething() |          |            |
|          | and execute it      | ---- reference to     |
|          -----------------------       function        |
|                                                        |
----------------------------------------------------------

The difference

If you want to use this for accessing the HTML element that is handling the
event, you must make sure that the this keyword is actually written into the
onclick property. Only in that case does it refer to the HTML element the event
handler is registered to. So if you do

  element.onclick = doSomething;
  alert(element.onclick)

you get

  function doSomething()
  {
      this.style.color = '#cc0000';
  }

As you can see, the this keyword is present in the onclick method. Therefore it
refers to the HTML element.

But if you do

<element onclick="doSomething()">
alert(element.onclick)

you get

function onclick()
{
    doSomething()
}

This is merely a reference to function doSomething(). The this keyword is not
present in the onclick method so it doesn't refer to the HTML element.

Examples - copying

this is written into the onclick method in the following cases:

  element.onclick = doSomething
  element.addEventListener('click',doSomething,false)
  element.onclick = function () {this.style.color = '#cc0000';}
  <element onclick="this.style.color = '#cc0000';">

Examples - referring

In the following cases this refers to the window:

  element.onclick = function () {doSomething()}
  element.attachEvent('onclick',doSomething)
  <element onclick="doSomething()">

Note the presence of attachEvent(). The main drawback of the Microsoft event
registration model is that attachEvent() creates a reference to the function
and does not copy it. Therefore it is sometimes impossible to know which HTML
currently handles the event.

Combination

When using inline event registration you can also send this to the function so
that you can still use it:

  <element onclick="doSomething(this)">

  function doSomething(obj) {
      // this is present in the event handler and is sent to the function
      // obj now refers to the HTML element, so we can do
      obj.style.color = '#cc0000';
  }



Refers to: http://www.quirksmode.org/js/this.html
-->
<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="description" content="" />
<meta name="keywords" content="" />
<title> front end 'this' of javascript, jquery </title>
</head>
<body>

  <h1> <i>`this` in javascript</i> 2014, 0311 </h1>
  <p id="dosomething"> Do something, click me.</p>
  <p onclick="changeColor()"> onclick="changeColor()" </p>
  <p onclick="objChangeColor(this)"> onclick="objChangeColor(this)" </p>
  <p onclick="showComments()"> onclick="showComments()" </p>
  <h1> Inspect object / Comments: </h1>
  <p id="show-this"> </p>

</body>

<script src="http://code.jquery.com/jquery.min.js"></script>
<script>
function _gg_get_color(){
  var color = ['#cc0000', '#00cc00', '#0000cc'];
  var length = color.length -1;
  var index = 0;

  function get_color(){
    if (index >= length){
      index = index - length;
    }else{
      index = index + 1;
    }
    return color[index];
  }
  return get_color;
}

function changeColor() {
  var color = _gg_get_color();
  $("p#show-this").html( inspect(this, 1));
  this.style.color = color();
}

function objChangeColor(obj, level) {
  if (typeof level === 'undefined' || level == null) level = 1;
  var color = _gg_get_color();
  $("p#show-this").html( inspect(obj, level));
  obj.style.color = color();
}

// To get comments in HTML doc
function getComment(){
  var nodes = document.childNodes;
  var all = [];
  for (var i = 0, len = nodes.length; i !== len; ++i) {
      if (nodes[i].nodeType === 8) {
          //console.log('Found comment' + nodes[i].nodeValue);
          all.push (nodes[i].nodeValue);
          //console.log('Found comment' + nodes[i].nodeValue);
      }
  }
  return all;
}

function showComments(){
  var comments = getComment();
  var joined = "<p><pre> \n";
  joined = joined + comments.join(" \n</pre>\n <hr /> <pre>\n ");
  joined += "</pre></p>\n";

  $("p#show-this").html(joined);

}

// old
var color1 = '#cc0000', color2 = '#00cc00', c = '#0000cc';

// Let's prepare to inspect something.
// Refers to: http://stackoverflow.com/questions/4716297/how-can-i-inspect-a-jquery-object

function inspect(obj, maxLevels, level)
{
  var str = '', type, msg;

  str = str + obj.toString() + " : \n";

  // Start Input Validations
  // Don't touch, we start iterating at level zero
  if(level == null)  level = 0;

  // At least you want to show the first level
  if(maxLevels == null) maxLevels = 1;
  if(maxLevels < 1)     
  return '<font color="red">Error: Levels number must be > 0</font>';

  // We start with a non null object
  if(obj == null)
  return '<font color="red">Error: Object <b>NULL</b></font>';
  // End Input Validations

  // Each Iteration must be indented
  str += '<ul>';

  // Start iterations for all objects in obj
  for(var property in obj)
  {
    try
    {
      type =  typeof(obj[property]);

      var property_string =  ': <b>null</b>' ;
      if (obj[property] !== null) property_string = obj[property].toString();

      str += '<li>(' + type + ') ' + 
        property +  ' : ' + 
        property_string +
        '</li>';

      // We keep iterating if this property is an Object, non null
      // and we are inside the required number of levels
      if((type == 'object') && (obj[property] != null) && (level+1 < maxLevels))
      str += inspect(obj[property], maxLevels, level+1);
    }catch(err)
    {
      // Are there some properties in obj we can't access? Print it red.
      if(typeof(err) == 'string') msg = err;
      else if(err.message)        msg = err.message;
      else if(err.description)    msg = err.description;
      else                        msg = 'Unknown';

      str += '<li><font color="red">(Error) ' + property + ': ' + msg +'</font></li>';
    }
  }

  // Close indent
  str += '</ul>';

  return str;
}
</script>
<script>
$( document ).ready(function() {

  //$("p#here").append( inspect($("p")));
  //$("p#here").append( inspect(window.document.location, 3));

  function doSomething() {
    c == color1 ? (c=color2) : (c=color1);

    $("p#show-this").html( inspect(this, 1));
    this.style.color = c;
  }


  $("#dosomething").click(doSomething);
});
</script>

</html>
<!-- vim: et ts=2 sw=2
-->
